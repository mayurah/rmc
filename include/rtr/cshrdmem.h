//|---------------------------------------------------------------------------
//|                Copyright (C) 1995 Reuters,                              --
//|               1400 Kensington Road, Oak Brook, Il. 60521                --
//|        All rights reserved. Duplication or distribution prohibited      --
//|---------------------------------------------------------------------------
//
// Author: A. MacGaffey
// Created: "Aug. 15 1995"
// Version: 1.0
//
// Modified: "Jul. 24 1997"
// Author: 	T. Zhang
// Version: 2.0

#ifndef _cshrdmem_h
#define _cshrdmem_h

#include "rtr/shmhdr.h"
#include "rtr/semlock.h"
#include "rtr/timercmd.h"
#include "rtr/objid.h"
#include "rtr/logevnt.h"
#include "rtr/portipc.h"

#include <sys/types.h>
#ifndef _RDEV_NO_STL_
#include <iostream>
#else
#include <stdio.h>
#endif


class RTRSharedMemoryClient;

// Synopsis:
// #include "rtr/cshrdmem.h
//
// Description:
// The encapsulation of the client side  of a server/client shared memory
// relationship. An instance of RTRClientSharedMemoryRoot is constructed
// with a key and will then attempt to attach to the shared memory associated
// with that key. If the attach is successful, the new client instance
// will attempt to register with the server providing the shared memory.
// If the attach/register fails, the client will periodically retry to attach.
// Once registration is completed, the client participates in a handshaking
// scheme which allows the client to determine whether or not the server is
// still alive (and vica versa). If a fatal error is encountered, the client
// instance enters an error state and makes no further attempts to attach.
// The attibute text() contains informational text regarding the state of the
// client.
//
// Various events may be generated by the client instance during its life-time.
// Descendants of RTRSharedMemoryClient may register with one or more
// instances of RTRClientSharedMemoryRoot in order to receive the events
// associated with that client. The events are:
//
// \bullet	
//	o clientError
//	o serverUp
//	o serverExit
//	o serverRestart
//	o serverInactive
// \endbullet
//
// For a detailed explanation of the event and a description of the default
// processing behaviour see below.
//
// Options:
//
// The attach procedure is as folows:
//
// \verbatim
// if shmget() fails
//	set a timer
// else
//	set an error condition
//
// if shmat() fails
//	set an error condition
//
// if header version is different
//	set an error condition
//
// initialize and allocate read/write lock
//
// if no more clients allowed
// 	detach and set a timer
//
// \endverbatim
//
// Timer processing is as follows
//
// \bullet	
// o if not attached attempt to attach ( only occurrs when polling enabled )
// o check for server restart
// o check for server exit
// o check for server time-out
// o mark this client alive
// \endbullet
//
// See Also:
//	RTRSharedMemoryClient, RTRServerSharedMemoryRoot, 
//	RTRSharedMemoryPartitionIterator
//
// Inherits:
//	RTRTimerCmd
//

class RTRClientSharedMemoryRoot :
	public RTRTimerCmd
{ 
public:
// Constructor
	RTRClientSharedMemoryRoot(
			const RTRString&,
			int pollInterval=2);
		// Obsolete
		// _TAG Constructor

	RTRClientSharedMemoryRoot(
			const RTRObjectId& context,
			const char *name,
			const RTRString&, 
			int pollInterval=2);
		// A shared memory attachment. 
		// _TAG Constructor

// Destructor
	~RTRClientSharedMemoryRoot();
		// _TAG Destructor

// Attributes
	inline const RTRString& text() const;
		// Text explaning the state of this shared memory root.
		// _TAG01 Attributes

	RTRString& key();
		// The key of the shared memory to which this client is (or will be)
		// attached.
		// _TAG01 Attributes

	inline HANDLE id() const;
		// The id of this session (assigned by this system)
		// REQUIRE : !error()
		// _TAG01 Attributes

	inline pid_t originalServerPid() const;
		// The server process id found after an initial attach to shared 
		// memory. (used to for detecting re-initialization of the segment)
		// _TAG01 Attributes

	pid_t currentServerPid() const;
		// The server process id stored in the current segment.
		// REQUIRE: attached()
		// _TAG01 Attributes

	int clientCount() const;
		// The number of clients of this segment.
		// _TAG01 Attributes

	inline RTRSharedMemoryHdr *header() const;
		// The header overlaid on the memory segment.
		// _TAG01 Attributes

	inline int shmemRuntimeVersion() const;
		// The run time version of the shared memory 
		// Currently two major versions are supported, 
		// one with C++ layout , runtime veriosn is 14 or 21
		// The other (newer) with C layout, runtime version > 2000
		// _TAG01 Attributes

// State
	virtual RTRBOOL error() const;
		// Is this client in an un-recoverable error state?
		// _TAG02 State

	RTRBOOL attached() const;
		// Is this client currently attached to shared memory?
		// _TAG02 State

	RTRBOOL connected() const;
		// Is this client registered and actively hand-shaking with the
		// server?
		// _TAG02 State

	RTRBOOL serverActive() const;
		// Is the server actively hand-shaking with the this client?
		// _TAG02 State

// Operations
	void acquireReadLock();
		// Acquire read lock on server partition lists
		//  REQUIRE: connected()
		// _TAG03 Operations

	void releaseReadLock();
		// Release read lock on server partition lists
		//  REQUIRE: connected()
		// _TAG03 Operations

// Access - sequential
	RTRSharedMemoryPartitionIterator partitionIterator() const;
		// Note: Read lock should be used when calling this method
		// REQUIRE: shmemRuntimeVersion() > 2000
		// REQUIRE: !error() 
		// REQUIRE: attached() 
		// _TAG04 Access -- sequential

	RTRSharedMemoryPartitionIterator_Eli partitionIteratorEli() const;
		// Note: Read lock should be used when calling this method
		// REQUIRE: shmemRuntimeVersion() < 2000
		// REQUIRE: !error() 
		// REQUIRE: attached() 
		// _TAG04 Access -- sequential

// Client management
	void addClient(RTRSharedMemoryClient& client);
		// Register the given client to receive segment events.
		// ENSURE : hasClient(client)
		// _TAG05 Client management

	void dropClient(RTRSharedMemoryClient& client);
		// Stop sending segment events to the given client.
		// ENSURE : !hasClient(client)
		// _TAG05 Client management

	RTRBOOL hasClient(RTRSharedMemoryClient&) const;
		// is the given client registered to receive segment events.
		// _TAG05 Client management

// Event processing
	void processTimerEvent();
		// _TAG06 Event processing

// Static data
	static char *fixedAddress;
		// Defaults to 0, meaning that system will assign the mapping
		// address for you. Modify this prior to construction to control
		// the mapping yourself.

protected:
// Operations -- utilities
	int getShmemRuntimeVersion(char* ) ;
	void init();
	void tryToAttach();
	void tryToConnect();
	void checkConnection();
	void cleanUp();
		// REQUIRE : !attached();
	RTRBOOL tryAcquireWriteLock();
	void releaseWriteLock();
	void deleteLock();

// Operations -- client notification
	void notifyClientError();
	void notifyServerUp();
	void notifyServerExit();
	void notifyServerInactive();
	void notifyServerRestart();

// Data
	RTRObjectId _instanceId;
	RTRString _key;
	int _pollInterval;		// reattach poll interval
	HANDLE _id;
	RTRBOOL _error;
	RTRBOOL _serverActive;
	RTRLogEvent _logEvent;
	int _lastLogMsg;
	pid_t _pid;
	pid_t _serverPid;		// Server pid from which client connection allocated
	RTRString _text;
	const char *_data;
	void *_notifier;

	int _runtimeVersion; // Determines what version of library to use
						 // C++ or C (newer version!)
		
#ifdef _WIN32
	RTRReadWriteLock_Eli *_lock0;
	RTRReadWriteLock *_lock;
#else
	RTRReadWriteLock *_lock;
#endif

	union {
		RTRSharedMemClientConnection_Eli *_clientConnection0;
		RTRSharedMemClientConnection *_clientConnection;
	};

	union {
		RTRSharedMemoryHdr_EliF14 *_header14; //Older version (oldest supported)
		RTRSharedMemoryHdr_EliF21 *_header21; //Older version (latest supported)
		RTRSharedMemoryHdr *_header;  //New version
	};

// Friends
	friend class RTRClientPartition_Eli; // For older versions
#ifndef _RDEV_NO_STL_
	friend std::ostream& operator<<(std::ostream&,
									const RTRClientSharedMemoryRoot&);
#else
public:
	void print(FILE*);
#endif
};

inline 
int RTRClientSharedMemoryRoot::shmemRuntimeVersion() const
{
	return _runtimeVersion;
}

inline 
const RTRString& RTRClientSharedMemoryRoot::text() const
{
	return _text;
}

inline 
HANDLE RTRClientSharedMemoryRoot::id() const 
{ 
	RTPRECONDITION ( !error() );
	return _id; 
}

inline 
pid_t RTRClientSharedMemoryRoot::originalServerPid() const
{
	return _serverPid;
}

inline 
RTRSharedMemoryHdr *RTRClientSharedMemoryRoot::header() const
{
	return _header;
}


// Synopsis:
// #include "rtr/cshrdmem.h"
//
// Description:
// RTRSharedMemoryClient is the abstract base class for application components
// which wish to register for events generated by one or more instances of
// RTRClientSharedMemoryRoot.
//
// See Also:
//	RTRClientSharedMemoryRoot
//

class RTRSharedMemoryClient
{
public:
// Event processing
	virtual void processClientError(RTRClientSharedMemoryRoot& shm) = 0;
		// An exception has occurred during the normal operations of the
		// the given memory client. If the client was polling, it will cease
		// to do so after this error event.
		// _TAG01 Event processing

	virtual void processServerUp(RTRClientSharedMemoryRoot& shm) = 0;
		// The server associated with the given shared memory
		// is up and running.
		// _TAG01 Event processing

	virtual void processServerExit(RTRClientSharedMemoryRoot&) = 0;
		// The server associated with the given shared memory client
		// has exited gracefully.
		// _TAG01 Event processing

	virtual void processServerInactive(RTRClientSharedMemoryRoot&) = 0;
		// The server associated with the given shared memory client
		// has been timed-out by the client.
		// _TAG01 Event processing

	virtual void processServerRestart(RTRClientSharedMemoryRoot&) = 0;
		// A server has re-initialized the shared memory associated with the
		// given shared memory client. Either the client memory root timed-out 
		// or the server was restarted after non-graceful termination and 
		// prior to time-out detection by the given client memory root.
		// _TAG01 Event processing

};

#endif
